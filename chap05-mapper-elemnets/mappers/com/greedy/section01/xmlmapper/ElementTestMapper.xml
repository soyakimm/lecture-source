<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
  <!-- 
  매퍼는 DAO 인터페이스와 동일한 패키지에 두고 DAO 인터페이스의 풀네임을 namespace로 지정해야 한다.
  또한 매퍼 인터페이스와 XML의 이름이 동일해야 하며
  작성한 메소드의 이름과 mapper의 id가 일치하며 리턴 타입이 일치하는 쿼리문을 모두 작성해야 한다. 
  -->
  
  
 <mapper namespace="com.greedy.section01.xmlmapper.ElementTestMapper"> <!-- 설정해주어야하는 최상위 엘리먼트 -->
 
 	<!-- Mapper xml에서 사용할 수 있는 엘리먼트는 총 9가지이다. -->
 	<!-- <cache>, <cache-ref>, <resultMap>, <parameterMap>, <sql> -->
 	<!-- <select>, <insert>, <update>, <delete> -->
 	
 	<!-- 1. <cache> 엘리먼트 -->
 	<!--  cache와 cache-ref 엘리먼트는 캐시를 설정하는 엘리먼트이다. 
 		   cache는 현재 네임스페이스에 대한 캐시 설78정이고, cache-ref는 다른 네임스페이스에 대한 캐시 설정을 참조할 때 사용한다.
 		  캐시란?
 		  컴퓨터 과학에서 데이터나 값을 미리 복사해 놓은 임시 장소를 가리킨다.
 		  캐시 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나, 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다.
 		  캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.
 	-->
	
	<cache eviction="LRU" flushInterval="1000" size="512" readOnly="true"/>
	
	<!-- 
		캐시의 디폴트 설정
		1. 매퍼 xml의 모든 select 구문의 결과를 캐시한다.
		2. 매퍼 xml의 insert, update, delete는 모두 캐시를 지운다.
		3. 가장 오랫동안 사용하지 않은 캐시를 지우는 알고리즘(LRU-Least Recently Used)을 사용한다.
		4. 애플리케이션이 실행되는 동안 캐시를 유지한다. 특정 시점에 사라지거나 하지 않는다. 
		5. 캐시는 최대 1025개까지 저장한다.
		6. 캐시는 읽기/쓰기가 모두 가능하다.
	 -->
	 
	 <!-- 
	 	사용 가능 속성
	 	1. eviction : 캐시 알고리즘 속성이며 디폴트는 LRU이다.
	 	2. flushInterval : 설정 된 캐시를 얼마 동안 유지할지를 밀리초 단위로 설정하며, 양수여야 한다.
	 	3. size : 캐시에 저장할 객체 수를 지정한다. 디폴트는 1024이다.
	 	4. readonly : 읽기만 가능한 경우 캐시 데이터의 변경이 되지 않는다.
	  -->
	
	<select id="selectCacheTest" resultType="java.lang.String">
		SELECT
			  MENU_NAME
		 FROM TBL_MENU
	</select>
	
	
	<!-- <resultMap> 테스트 -->
	
	<!--  2. <resultMap> 엘리먼트 -->
	<!-- 
		데이터베이스 결과 데이터를 객체에 로드하는 방법을 정의하는 엘리먼트이다.
		마이바티스에서 가장 중요하고 강력한 엘리먼트로 ReusltSet에서 데이터를 가져올 때 작성되는 
		JDBC코드를 배부분 줄여주는 역할을 담당한다.
		
		속성 
		1. id : 매핑 구문에서 결과 매핑을 사용할 때 구분하기 위한 아이디 == pk
		2. type : 결과 매핑을 적용하는 대상 객체 타입(매핑의 구분 결과 데이터를 저장할 자바 타입을 지정함)
		3. extends : 자바의 상속처럼 기존에 정의 된 매핑 결과를 상속 받아 추가적인 매핑 정보로 확장할 때 사용
		4. auotoMapping : 결과 매핑을 자동 매핑 할 것인지 결정함
						  오토 매핑 설정은 동일한 컬럼명이 있는 경우 위험성을 가지기 때문에 사용하지 않는 것이 안전한다.
	 -->
	 
  <resultMap id="menuResultMap1" type="com.greedy.common.MenuDTO" autoMapping="false">
	 <id property="code" column="MENU_CODE"/>
	 <result property="name" column="MENU_NAME"/>
	 <result property="price" column="MENU_PRICE"/>
	 <result property="categoryCode" column="CATEOGRY_CODE"/>
  </resultMap>
  <resultMap id="menuResultMap2" type="com.greedy.common.MenuDTO" extends="menuResultMap1">
  <!--  extends : map1을 상속받고, 나만의 추가적인 속성만 넣는다. -->
  	<result property="orderableStatus" column = "ORDERABLE_STATUS"/>
  	<!-- 하나의 컬럼만 넣어도 상단의 name, price, cateogoryCode 등이 이미 있음 -->
  </resultMap>
  
  	<select id="selectResultMapTest" resultMap="menuResultMap2">
  	<!-- 상속받은 menuResultMap2을 이용해 수행해본다. -->
		SELECT 
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU
		 WHERE ORDERABLE_STATUS = 'Y'
	</select>

  	
  	
  	
  	<!--  <constructor> 테스트  -->
  	
  	<!--  2.1 resultMap 하위 엘리먼트 -->
  	<!--  
  		<id> : PK 컬럼을 매핑하기 위한 태그
  		<result> : pk가 아닌 일반 컬럼에 매핑하기 위한 태그이다.
  		<constructor> : 인스턴스화 되는 클래스의 생성자에 결과를 삽입하기 위해 사용한다. <idArg>, <arg> 하위 엘리먼트가 있다.
  		<association> : 복잡한 타입의 연관 관계로 1:1 포함 관계인 경우 사용한다.
  		<collection> : 복잡한 타입의 연관 관계로 1:N 포함 관계인 경우 사용한다.
  	 -->
  	
  	
  	<!-- 2-1-1. <constructor> -->
 <resultMap id="menuResultMap3" type="com.greedy.common.MenuDTO">
  	<!-- id, result 엘리먼트를 이용하여 setter를 이용하기 때문에 property를 지정하지만
  	 	생성자는 순서와 타입을 맞춰서 사용해야 한다. 
  	 	idArg
  	 	arg 
  	-->
  		<constructor>
			<idArg column="MENU_CODE" javaType="_int"/>
			<arg column="MENU_NAME" javaType="string"/>
			<arg column="MENU_PRICE" javaType="_int"/>
			<arg column="CATEGORY_CODE" javaType="_int"/>
			<arg column="ORDERABLE_STATUS" javaType="string"/>
		</constructor>
	</resultMap>

  	
	<select id="selectResultMapConstructorTest" resultMap="menuResultMap3">
		SELECT 
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU
		 WHERE ORDERABLE_STATUS = 'Y'	
	</select>

	 
	 
	 <!-- 2-1-2. <association> -->

	 <!--  주의점 
	 		<association>은 중간에 넣으면 에러가 발생한다. 가장 마지막 부분에 넣어야 한다.
	  -->	 
	  <!-- 별도로 작성한 resultMap을 사용한 방법 -->
<!-- 	 <resultMap id="menuAndCategoryReusltMap" type="com.greedy.common.MenuAndCategoryDTO">
	 	<id property="code" column="MENU_CODE"/>
	 	<result property="name" column="MENU_NAME"/>
	 	<result property="price" column="MENU_PRICE"/>
	 	<result property="orderableStatus" column="ORDERABLE_STATUS"/>
	 	<association property="category" resultMap="categoryReusltMap"></association>
	 	property: 속성 필드 resultMap: mapping한 이름
	 </resultMap>
	 <resultMap id="categoryReusltMap" type="com.greedy.common.CategoryDTO">
	 	<id property="code" column="CATEGORY_CODE"/>
	 	<result property="name" column="CATEGORY_NAME"/>
	 	<result property="refCategoryCode" column="REF_CATEGORY_CODE"/>
	 </resultMap>	 --> 
	 
	 <!--  association 내에 id, result 작성하는 방법 -->
	<resultMap id="menuAndCategoryResultMap" type="com.greedy.common.MenuAndCategoryDTO">
		<id property="code" column="MENU_CODE"/>
		<result property="name" column="MENU_NAME"/>
		<result property="price" column="MENU_PRICE"/>
		<result property="orderableStatus" column="ORDERABLE_STATUS"/>
		<association property="category" javaType="com.greedy.common.CategoryDTO">
			<id property="code" column="CATEGORY_CODE"/>
			<result property="name" column="CATEGORY_NAME"/>
			<result property="refCategoryCode" column="REF_CATEGORY_CODE"/>
		</association>
	</resultMap>

	
	 
	<select id="selectResultMapAssociationTest" resultMap="menuAndCategoryResultMap">
		SELECT 
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , CATEGORY_NAME
		     , REF_CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU
		  JOIN TBL_CATEGORY USING (CATEGORY_CODE)
		 WHERE ORDERABLE_STATUS = 'Y'		
	</select>
	
	<!-- 2-1-3. <collection> -->
	
<!-- 	
	  따로 만든 resultMap을 사용하는 방법 
	<resultMap type="com.greedy.common.CategoryAndMenuDTO" id="categoryAndMenuResultMap">
		<id property="code" column="CATEGORY_CODE"/>
		<result property="name" column="CATEGORY_NAME"/>
		<result property="refCategoryCode" column="REF_CATEGORY_CODE"/>
		<collection property="menuList" resultMap="menuResultMap"/>
	</resultMap>
	MENUDTO에 대해 처리하는 resultmap
	<resultMap type="com.greedy.common.MenuDTO" id="menuResultMap">
		<id property="code" column="MENU_CODE"/>
		<result property="name" column="MENU_NAME"/>
		<result property="price" column="MENU_PRICE"/>
		<result property="categoryCode" column="CATEGORY_CODE"/>
		<result property="orderableStatus" column="ORDERABLE_STATUS"/>
	</resultMap> 
-->
	
	<!--  collection 내에 id, result 작성하는 방법 -->
	<resultMap type="com.greedy.common.CategoryAndMenuDTO" id="categoryAndMenuResultMap">
		<id property="code" column="CATEGORY_CODE"/>
		<result property="name" column="CATEGORY_NAME"/>
		<result property="refCategoryCode" column="REF_CATEGORY_CODE"/>
		<collection property="menuList" ofType="com.greedy.common.MenuDTO">
			<id property="code" column="MENU_CODE"/>
		<result property="name" column="MENU_NAME"/>
		<result property="price" column="MENU_PRICE"/>
		<result property="categoryCode" column="CATEGORY_CODE"/>
		<result property="orderableStatus" column="ORDERABLE_STATUS"/>
		</collection>
	</resultMap>
	
	
	<select id="selectResultMapCollectionTest" resultMap="categoryAndMenuResultMap">
		SELECT
				A.CATEGORY_CODE
			  , A.CATEGORY_NAME
			  , A.REF_CATEGORY_CODE
			  , B.MENU_CODE
			  , B.MENU_NAME
			  , B.MENU_PRICE
			  , B.CATEGORY_CODE
			  , B.ORDERABLE_STATUS
		 FROM TBL_CATEGORY A
		 LEFT JOIN TBL_MENU B ON (A.CATEGORY_CODE = B.CATEGORY_CODE)
		ORDER BY A.CATEGORY_CODE
	</select>

	 
	 <!-- 3. <sql> 엘리먼트 -->
	 <!-- 
	 	각 매핑 구문에서 공통으로 사용할 수 있는 SQL 문자열의 일부를 정의하고 재사용하기 위해 사용한다.
	  -->
	 <sql id="columns">
	 	MENU_CODE
	  , MENU_NAME
	  , MENU_PRICE
	  , CATEGORY_CODE
	  , ORDERABLE_STATUS
	 </sql>
	 
	 
	 <select id="selectSqlTest" resultMap="menuResultMap2">
	 	SELECT
	 	<include refid="columns"/>
	 	  FROM TBL_MENU
	 	 WHERE ORDERABLE_STATUS = 'Y'
	 </select>
	 
	<!-- 4. <insert> 엘리먼트 -->	 
	<!-- 
		insert, update, delete 엘리먼트는 사용하는 속성이 대부분 동일하지만 insert 엘리먼트는 좀 더 많은 속성을 정의할 수 있다.
		
		<공통 속성>
		id : 매핑 구문을 구분하는 아이디
		parameterType : 파라미터의 타입을 지정한다. 이미 정의 된 별칭이 있다면 사용할 수도 있고, 클래스의 full-name을 적어주면 된다.
		flushCache : 매핑 구문을 실행할 때 캐시를 지을지 여부를 설정한다. / 기본: 지운다
		timeout : sql을 실행한 후 응답을 기다리는 최대 시간이다. 대게는 설정하지 않고 JDBC 드라이버 자체의 타임아웃 값을 그대로 사용한다.
		statementType : JDBC 구문 타입을 지정한다. STATEMENT, PREPARED, CALLABLE 중 하나를 쓸 수 있으며 기본 값은 PREPARED이다.
		~ JDBC속성동일 ~
		- STATEMENT
		- PREPAREDSTATEMENT 	
		
		<insert 추가 속성>
		keyProperty : insert 구문의 하위 엘리먼트인 selectKey 엘리먼트에 의한 반환값을 설정할 프로터리를 지정함
	 -->
	 
	 <insert id="insertNewCategory">
	 	INSERT
	 	  INTO TBL_CATEGORY
	 	 (
	 	 CATEGORY_CODE
	 	,CATEGORY_NAME
	 	,REF_CATEGORY_CODE
	 	 )
		VALUES
		(
		 SEQ_CATEGORY_CODE.NEXTVAL
		,#{ category.name }
		<!-- cateogry객체 안에 name필드값 -->
		,NULL
		)
	 </insert>
	 
	 	<insert id="insertNewMenu">
		<selectKey keyProperty="category.code" order="BEFORE" resultType="_int">
			SELECT
			       SEQ_CATEGORY_CODE.CURRVAL
			  FROM DUAL
		</selectKey>
		INSERT
		  INTO TBL_MENU
		(
		  MENU_CODE
		, MENU_NAME
		, MENU_PRICE
		, CATEGORY_CODE
		, ORDERABLE_STATUS
		)
		VALUES
		(
		  SEQ_MENU_CODE.NEXTVAL
		, #{ name }
		, #{ price }
		, #{ category.code }
		, #{ orderableStatus }
		)
	</insert>

	 
	 
	 <!-- 5. <select> 엘리먼트 -->
	<!-- 
		(1) 자주 사용되는 속성
	    select 엘리먼트의 경우 많이 사용되는 속성은 앞에서 다룬 속성들이다.
	    id : 매핑 구문을 구분하는 아이디이다.
	    parameterType : 파라미터의 타입을 의미한다. 이미 정의된 타입을 사용할 수 있으며, 개발자가 정의한 타입을 사용하는 경우 full-name을 기술한다.
	    예: java.lang.String
	    resultType : 매핑 구문의 결과 행 타입이다. 전체 결과의 타입을 지정하는 것이 아닌 1 row에 해당하는 타입을 설정해야 한다.
	    resultMap : 매핑 구문의 결과 행을 미리 선언한 resultMap을 이용한다는 의미이다. 전체 행이 아닌 1 row에 해당하는 resultMap을 지정한다.
	    
	    (2) 자주 사용되지 않는 속성
	    flushCache : 구문을 호출할 때마다 캐시를 지울지 여부를 설정한다.
	    useCache : 구문의 결과를 캐시한다. 기본값 true
	    timeout : 구문을 실행하고 응답을 기다리는 최대 시간이다. 대게는 설정하지 않고 JDBC 드라이버 자체의 타임아웃 값을 그대로 사용한다.
	    fetchSize : 지정된 수 만큼의 결과를 반환하게 하는 드라이버 힌트 형태의 값이다. 디폴트는 설정하지 않는 것이며 일부 드라이버는 지원하지 않는다.
	    statementType : JDBC의 구문 타입을 지정한다. STATEMENT, PREPARED, CALLABLE 중 하나이며 디폴트는 PREPARED이다.
	    resultSetType : ResultSet의 커서 이동 방향을 지정한다. FORWARD_ONLY, SCROLL_SENSITIVE, SCROLL_INSENCITIVE 중 하나를 설정한다.
	                                        기본값은 FORWARD_ONLY이며, 커서가 앞으로만 이동한다.
	                    SCROLL_SENSITIVE는 커서가 앞뒤로 이동할 수 있고, ResultSet 객체 생성 후 추가 및 삭제된 데이터도 볼 수 있다.
	                    SCROLL_INSENSITIVE는 커서가 앞뒤로 이동할 수 있지만 ResultSet 객체 생성 후 추가 및 삭제된 데이터는 볼 수 없다.
	 
	 -->
	 
	 
</mapper>
