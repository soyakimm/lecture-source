<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  
  <!-- 
  매퍼는 DAO 인터페이스와 동일한 패키지에 두고 DAO 인터페이스의 풀네임을 namespace로 지정해야 한다.
  또한 매퍼 인터페이스와 XML의 이름이 동일해야 하며
  작성한 메소드의 이름과 mapper의 id가 일치하며 리턴 타입이 일치하는 쿼리문을 모두 작성해야 한다. 
  -->
  
  
 <mapper namespace="com.greedy.section01.xml.DynamicSqlMapper"> <!-- 설정해주어야하는 최상위 엘리먼트 -->
 
 	<resultMap type="com.greedy.common.MenuDTO" id="menuResultMap">
 		<id property="code" column="MENU_CODE"/>
 		<result property="name" column="MENU_NAME"/>
 		<result property="price" column="MENU_PRICE"/>
 		<result property="categoryCode" column="CATEGORY_CODE"/>
 		<result property="orderableStatus" column="ORDERABLE_STATUS"/>
 	</resultMap>
 
 	<select id="selectMenuByPrice" parameterType="hashmap" resultMap="menuResultMap"> 
 	<!-- resultMap=수행후 어떻게 매핑 -->
 		SELECT
 				MENU_CODE
 			  , MENU_NAME
 			  , MENU_PRICE
 			  , CATEGORY_CODE
 			  , ORDERABLE_STATUS
 		 FROM TBL_MENU
 		WHERE ORDERABLE_STATUS = 'Y'
 		<!-- test="조건" -->
 		<!--  
 		gte : >= , lte : <=  , gt : >
 		CDATA : 등위를 등위로써 인식하게끔 한다.
 		-->
 		<if test="price gte 0 and price lte 10000">
		<!-- if문이 만족했을 때, 작동하는 코드 --> 
				
		<![CDATA[
			AND MENU_PRICE < #{price} 		
		]]>
 		</if>
 		<if test="price gt 10000 and price lte 20000">
 			AND MENU_PRICE BETWEEN 10000 AND #{price}
 		</if>
 		<if test="price gt 20000 and price lte 30000">
 			AND MENU_PRICE BETWEEN 20000 AND #{price}
 		</if>
 		<if test="price gt 30000">
 			AND MENU_PRICE BETWEEN 30000 AND #{price}
 		</if>
 		ORDER BY MENU_CODE
 	</select>
 	
 	
 	<!-- 2번 
 	id : 메소드명 -->
	<select id="searchMenuByRandomMenuCode" parameterType="hashmap" resultMap="menuResultMap">
		SELECT
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU	
	     WHERE ORDERABLE_STATUS = 'Y'	
	       AND MENU_CODE IN
	     <foreach collection="randomMenuCodeList" item="menuCode" open="(" separator=", " close=")">
	     	   #{ menuCode }
	     </foreach>
	</select>
	
	<select id="searchMenuByCodeOrSearchAll" parameterType="SearchCriteria" resultMap="menuResultMap">
		SELECT
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU	
		  <if test="condition != null and condition eq 'menuCode'">
		  	<where>
		  		MENU_CODE = #{ value }
		  	</where>
		  </if>		
	
	</select>

 <select id="searchMenuByNameOrCategory" parameterType="hashmap" resultMap="menuResultMap">
		SELECT
		       MENU_CODE
		     , MENU_NAME
		     , MENU_PRICE
		     , CATEGORY_CODE
		     , ORDERABLE_STATUS
		  FROM TBL_MENU		
		
		<!-- 문제 발생 : 카테고리로 조회하는 경우 where이 붙지 않기 때문에 이렇게 조회할 수 없다. -->
		<!-- <if test="nameValue != null">
		 WHERE MENU_NAME LIKE '%' || #{ nameValue } || '%'
		</if>
		<if test="categoryValue != null">
		   AND CATEGORY_CODE = #{ categoryValue } 
		</if> -->
		
		<!-- 해결 방법 1. <where> 태그를 이용한다. -->
		<!-- 
			where 태그는 앞에 where로 시작하지 않으면 자동으로 where을 붙여준다.
			또한 where절 내부에 모두 쿼리문이 추가되지 않는 상황인 경우 where를 무시한다.
			and나 or로 시작을 하게 되면 자동으로 해당 단어를 지워준다.
		 -->
<!-- 		<where>
			<if test="nameValue != null">
		 		MENU_NAME LIKE '%' || #{ nameValue } || '%'
			</if>
			<if test="categoryValue != null">
			   AND CATEGORY_CODE = #{ categoryValue } 
			</if>
		</where> -->
		
		<!-- 해결 방법 2. <trim> 태그를 이용한다. -->
		<!-- 
			조회 조건에 and 혹은 or로 시작하지 않는 다른 문자로 시작하는 경우
			where 엘리먼트가 기본적으로 처리하는 기능에 추가 규칙을 정의하기 위해 trim 엘리먼트를 제공한다.
			prefix : 처리 후 엘리먼트의 내용이 있으면 가장 앞에 붙여주는 내용을 기술한다.
			prefixOverrides : 처리 후 엘리먼트의 내용 중 가장 앞에 해당하는 문자들이 있다면 자동으로 지워준다.
			suffix : 처리 후 엘리먼트 내에 내용이 있으면 가장 뒤에 붙여준다.
			suffixOverrides : 처리 후 엘리먼트 내용 중 가장 뒤에 해당 문자들이 있다면 자동으로 지워준다.
		 -->
<!--  		 <trim prefix="WHERE" prefixOverrides="AND | OR">
		 	<if test="nameValue != null">
		 		MENU_NAME LIKE '%' || #{ nameValue } || '%'
			</if>
			<if test="categoryValue != null">
			   AND CATEGORY_CODE = #{ categoryValue } 
			</if>
		 </trim>
-->

	<!-- 
	 bind : 변수를 만든 후 바인딩 한다.  
	 이때 _parameter가 파라미터로 전달 된 Object를 의미하며, Collection의 경우 get
	 Object의 경우 getter를 사용한다.	 
	-->
	<trim prefix="WHERE" prefixOverrides="AND | OR">
		 	<bind name="namePattern" value="'%' + _parameter.get('nameValue') + '%'"/>
		 
		 	<if test="nameValue != null">
		 		MENU_NAME LIKE #{ namePattern }
			</if>
			<if test="categoryValue != null">
			   AND CATEGORY_CODE = #{ categoryValue } 
			</if>
		 </trim>
	</select>
	
	<update id="modifyMenu" parameterType="hashmap">
		<!-- 
			값을 입력한 일부 컬럼만 값을 변경하려고 if 엘리먼트를 이용하였으나
			변경할 메뉴 이름을 입력하지 않은 경우 SET이 빠지기 때문에 set 키워드가 누락 되었다는 오류가 발생한다.
			또는 set 키워드가 있더라도 , 가 앞에 붙거나 뒤에 붙어 문법적인 오류가 발생한다.
		 -->
		<!-- UPDATE
		       TBL_MENU
		<if test="name != null and name != ''">
	       SET MENU_NAME = #{ name }
		</if>
		<if test="categoryCode != null and categoryCode gt 0">
		     , CATEGORY_CODE = #{ categoryCode }
		</if>
		<if test="orderableStatus != null and orderableStatus != ''">
		     , ORDERABLE_STATUS = #{ orderableStatus }
		</if>
		 WHERE MENU_CODE = #{ code } -->
		 
		 
		 
		 <!-- 해결 방법 1. <set> 엘리먼트 사용 -->
		 <!-- 
		 	<set> 엘리먼트 내부에 내용이 있을 시 set 구문을 자동으로 추가해준다.
		 	앞 또는 뒤에 붙은 콤마를 제거해준다.
		  -->
		 
<!-- 		 UPDATE
		       TBL_MENU
		<set>
		<if test="name != null and name != ''">
	        MENU_NAME = #{ name }
		</if>
		<if test="categoryCode != null and categoryCode gt 0">
		     , CATEGORY_CODE = #{ categoryCode }
		</if>
		<if test="orderableStatus != null and orderableStatus != ''">
		     , ORDERABLE_STATUS = #{ orderableStatus }
		</if>
		</set>
		 WHERE MENU_CODE = #{ code } -->
		 
		
		<!-- 해결방법 2. <trim> 엘리먼트 사용 --> 
		UPDATE
		       TBL_MENU
		<trim prefix="SET" prefixOverrides=",">
		<if test="name != null and name != ''">
	        MENU_NAME = #{ name } 
		</if>
		<if test="categoryCode != null and categoryCode gt 0">
		     , CATEGORY_CODE = #{ categoryCode } 
		</if>
		<if test="orderableStatus != null and orderableStatus != ''">
		     , ORDERABLE_STATUS = #{ orderableStatus }
		</if>
		</trim>
		 WHERE MENU_CODE = #{ code }
	
	</update>
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</mapper>
